<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/RETURN_BOOK_FIXES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/RETURN_BOOK_FIXES.md" />
              <option name="updatedContent" value="# Correctifs pour le retour de livres&#10;&#10;## Problèmes identifiés&#10;&#10;### 1. Scanner de code-barres ML Kit&#10;**Erreur** : `com.google.mlkit.common.MlKitException: This detector is already closed!`&#10;&#10;**Cause** : Le scanner était fermé immédiatement après la première détection, mais continuait à recevoir des frames.&#10;&#10;**Solution** : &#10;- Ajout d'un flag `@Volatile isScanning` pour arrêter les analyses après détection&#10;- Méthode `close()` séparée appelée lors de la destruction de la vue&#10;- Gestion propre du cycle de vie avec `onRelease` dans `AndroidView`&#10;&#10;### 2. Retour de livre non synchronisé&#10;**Problème** : Le livre retourné par l'emprunteur ne revenait pas dans la bibliothèque du prêteur.&#10;&#10;**Cause** : Chaque téléphone a sa propre base de données Room locale. La suppression côté emprunteur n'affectait pas le prêteur.&#10;&#10;**Solution** :&#10;1. **Ajout d'un endpoint API** `POST /shareMyBook/return/{bookId}` pour notifier le backend du retour&#10;2. **Ajout d'un endpoint API** `GET /shareMyBook/bookStatus/{bookId}` pour vérifier le statut d'un livre&#10;3. **Modification de `ReturnTransactionViewModel`** : Appel de l'API lors de la confirmation du retour&#10;4. **Modification de `ConfirmReturnViewModel`** : Polling de l'API (toutes les 2 secondes) pour détecter le retour&#10;&#10;## Fichiers modifiés&#10;&#10;### 1. ScannerActivity.kt&#10;- Ajout du flag `isScanning` dans `BarcodeAnalyzer`&#10;- Méthode `close()` pour fermer proprement le scanner&#10;- Utilisation de `remember` pour l'analyseur&#10;- Callback `onRelease` dans `AndroidView`&#10;&#10;### 2. TransactionService.kt&#10;```kotlin&#10;@POST(&quot;shareMyBook/return/{bookId}&quot;)&#10;suspend fun returnBook(@Path(&quot;bookId&quot;) bookId: String, @Body request: AcceptRequest): TransactionData&#10;&#10;@GET(&quot;shareMyBook/bookStatus/{bookId}&quot;)&#10;suspend fun getBookStatus(@Path(&quot;bookId&quot;) bookId: String): TransactionData&#10;```&#10;&#10;### 3. BookRepository.kt&#10;```kotlin&#10;suspend fun returnBook(bookId: String, borrower: User): TransactionData&#10;suspend fun getBookStatus(bookId: String): TransactionData&#10;```&#10;&#10;### 4. ReturnTransactionViewModel.kt&#10;- Appel de `bookRepository.returnBook()` avant suppression locale&#10;- Gestion des erreurs avec continuation même en cas d'échec API&#10;&#10;### 5. ConfirmReturnViewModel.kt&#10;- Polling de l'API avec `bookRepository.getBookStatus()`&#10;- Mise à jour automatique de la base locale quand le retour est détecté&#10;- Timeout de 2 minutes (60 tentatives × 2 secondes)&#10;&#10;## Architecture du système de retour&#10;&#10;### Flux de retour d'un livre&#10;&#10;1. **Prêteur** : Clique sur &quot;Retourner&quot; dans l'onglet &quot;Mes prêts&quot;&#10;   - Ouvre `ConfirmReturnActivity`&#10;   - Génère un QR code contenant `{ &quot;bookUid&quot;: &quot;...&quot;, &quot;lenderUid&quot;: &quot;...&quot; }`&#10;   - Lance le polling de l'API toutes les 2 secondes&#10;&#10;2. **Emprunteur** : Clique sur &quot;Retourner&quot; dans l'onglet &quot;Mes emprunts&quot;&#10;   - Ouvre `ScannerActivity`&#10;   - Scanne le QR code du prêteur&#10;   - Ouvre `ReturnTransactionActivity`&#10;   - Confirme le retour&#10;   - **Appelle l'API backend** `POST /shareMyBook/return/{bookId}`&#10;   - Supprime le livre de sa base locale&#10;&#10;3. **Backend** : Reçoit la notification de retour&#10;   - Met à jour le statut du livre (borrowerId = null)&#10;   - Stocke l'information dans Firebase&#10;&#10;4. **Prêteur** : Son polling détecte le changement&#10;   - `GET /shareMyBook/bookStatus/{bookId}` retourne borrowerId = null&#10;   - Met à jour sa base locale (borrowerId = null, lenderId = null)&#10;   - Affiche &quot;Livre retourné avec succès !&quot;&#10;   - Le livre redevient disponible dans &quot;Ma bibliothèque&quot;&#10;&#10;## Configuration Backend requise&#10;&#10;⚠️ **IMPORTANT** : Le backend Firebase Cloud Functions doit implémenter les endpoints suivants :&#10;&#10;### 1. POST /shareMyBook/return/{bookId}&#10;```javascript&#10;// Reçoit: { borrower: { uid, fullName } }&#10;// Met à jour le livre dans Firestore: borrowerId = null&#10;// Retourne: TransactionData avec le livre mis à jour&#10;```&#10;&#10;### 2. GET /shareMyBook/bookStatus/{bookId}&#10;```javascript&#10;// Interroge Firestore pour obtenir le statut actuel du livre&#10;// Retourne: TransactionData avec les informations du livre&#10;```&#10;&#10;## Tests à effectuer&#10;&#10;1. ✅ **Scanner sans crash** : Vérifier que le scanner ne plante plus après détection&#10;2. ✅ **Retour simple** : &#10;   - Prêteur génère QR code&#10;   - Emprunteur scanne et confirme&#10;   - Prêteur voit le livre revenir (max 2 secondes)&#10;3. ✅ **Timeout** : Vérifier que le message d'erreur s'affiche après 2 minutes si pas de retour&#10;4. ✅ **Erreur API** : Tester avec le backend arrêté pour vérifier la gestion d'erreur&#10;&#10;## Améliorations futures&#10;&#10;1. **Notifications Push** : Utiliser Firebase Cloud Messaging pour notifier immédiatement le prêteur&#10;2. **Cache API** : Éviter de surcharger l'API avec trop de requêtes&#10;3. **Retry logic** : Réessayer automatiquement en cas d'échec réseau&#10;4. **Offline mode** : Mettre en file d'attente les retours si pas de connexion&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>